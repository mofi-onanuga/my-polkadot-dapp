{"version":3,"file":"watch.js","sourceRoot":"","sources":["../../src/lib/watch.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,SAAS,EAAC,MAAM,kBAAkB,CAAC;AAC3C,OAAO,EAAC,cAAc,EAAC,MAAM,wBAAwB,CAAC;AAGtD,MAAM,cAAe,SAAQ,cAAc;IAIhC,MAAM,CAAC,MAAuB;;QACrC,IAAI,MAAM,KAAK,IAAI,CAAC,QAAQ,EAAE,CAAC;YAC7B,MAAA,IAAI,CAAC,SAAS,oDAAI,CAAC;YACnB,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC;YAEvB,oEAAoE;YACpE,gDAAgD;YAChD,IAAI,aAAa,GAAG,IAAI,CAAC;YACzB,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,KAAK,EAAE,EAAE;gBAC1C,qEAAqE;gBACrE,sEAAsE;gBACtE,IAAI,aAAa,KAAK,KAAK,EAAE,CAAC;oBAC5B,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;gBACvB,CAAC;YACH,CAAC,CAAC,CAAC;YACH,aAAa,GAAG,KAAK,CAAC;QACxB,CAAC;QAED,uEAAuE;QACvE,qEAAqE;QACrE,oEAAoE;QACpE,qDAAqD;QACrD,OAAO,MAAM,CAAC,IAAI,EAAE,CAAC;IACvB,CAAC;IAEkB,YAAY;;QAC7B,MAAA,IAAI,CAAC,SAAS,oDAAI,CAAC;IACrB,CAAC;IAEkB,WAAW;;QAC5B,kEAAkE;QAClE,0EAA0E;QAC1E,qEAAqE;QACrE,EAAE;QACF,mDAAmD;QACnD,0CAA0C;QAC1C,sDAAsD;QACtD,0EAA0E;QAC1E,iEAAiE;QACjE,yEAAyE;QACzE,2EAA2E;QAC3E,0EAA0E;QAC1E,kEAAkE;QAClE,IAAI,CAAC,SAAS,GAAG,MAAA,IAAI,CAAC,QAAQ,0CAAE,SAAS,CAAC,CAAC,KAAK,EAAE,EAAE;YAClD,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QACvB,CAAC,CAAC,CAAC;IACL,CAAC;CACF;AAED;;;GAGG;AACH,MAAM,CAAC,MAAM,KAAK,GAAG,SAAS,CAAC,cAAc,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {directive} from 'lit/directive.js';\nimport {AsyncDirective} from 'lit/async-directive.js';\nimport {type Signal} from '@preact/signals-core';\n\nclass WatchDirective extends AsyncDirective {\n  private __signal?: Signal;\n  private __dispose?: () => void;\n\n  override render(signal: Signal<unknown>) {\n    if (signal !== this.__signal) {\n      this.__dispose?.();\n      this.__signal = signal;\n\n      // Whether the subscribe() callback is called because of this render\n      // pass, or because of a separate signal update.\n      let updateFromLit = true;\n      this.__dispose = signal.subscribe((value) => {\n        // The subscribe() callback is called synchronously during subscribe.\n        // Ignore the first call since we return the value below in that case.\n        if (updateFromLit === false) {\n          this.setValue(value);\n        }\n      });\n      updateFromLit = false;\n    }\n\n    // We use peek() so that the signal access is not tracked by the effect\n    // created by SignalWatcher.performUpdate(). This means that a signal\n    // update won't trigger a full element update if it's only passed to\n    // watch() and not otherwise accessed by the element.\n    return signal.peek();\n  }\n\n  protected override disconnected(): void {\n    this.__dispose?.();\n  }\n\n  protected override reconnected(): void {\n    // Since we disposed the subscription in disconnected() we need to\n    // resubscribe here. We don't ignore the synchronous callback call because\n    // the signal might have changed while the directive is disconnected.\n    //\n    // There are two possible reasons for a disconnect:\n    //   1. The host element was disconnected.\n    //   2. The directive was not rendered during a render\n    // In the first case the element will not schedule an update on reconnect,\n    // so we need the synchronous call here to set the current value.\n    // In the second case, we're probably reconnecting *because* of a render,\n    // so the synchronous call here will go before a render call, and we'll get\n    // two sets of the value (setValue() here and the return in render()), but\n    // this is ok because the value will be dirty-checked by lit-html.\n    this.__dispose = this.__signal?.subscribe((value) => {\n      this.setValue(value);\n    });\n  }\n}\n\n/**\n * Renders a signal and subscribes to it, updating the part when the signal\n * changes.\n */\nexport const watch = directive(WatchDirective);\n"]}