{"version":3,"file":"signal-watcher.js","sourceRoot":"","sources":["../../src/lib/signal-watcher.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAGH,OAAO,EAAC,MAAM,EAAC,MAAM,sBAAsB,CAAC;AAO5C;;;;GAIG;AACH,MAAM,UAAU,aAAa,CAC3B,IAAO;IAEP,MAAe,aAAc,SAAQ,IAAI;QAG9B,aAAa;;YACpB,sEAAsE;YACtE,sEAAsE;YACtE,WAAW;YACX,IAAI,IAAI,CAAC,eAAe,KAAK,KAAK,EAAE,CAAC;gBACnC,OAAO;YACT,CAAC;YACD,2CAA2C;YAC3C,MAAA,IAAI,CAAC,SAAS,oDAAI,CAAC;YAEnB,wEAAwE;YACxE,wCAAwC;YACxC,IAAI,aAAa,GAAG,IAAI,CAAC;YAEzB,iEAAiE;YACjE,qEAAqE;YACrE,oDAAoD;YACpD,sDAAsD;YACtD,0BAA0B;YAC1B,kBAAkB;YAClB,iDAAiD;YACjD,+CAA+C;YAC/C,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,GAAG,EAAE;gBAC3B,IAAI,aAAa,EAAE,CAAC;oBAClB,aAAa,GAAG,KAAK,CAAC;oBACtB,KAAK,CAAC,aAAa,EAAE,CAAC;gBACxB,CAAC;qBAAM,CAAC;oBACN,oDAAoD;oBACpD,8DAA8D;oBAC9D,sDAAsD;oBACtD,IAAI,CAAC,aAAa,EAAE,CAAC;gBACvB,CAAC;YACH,CAAC,CAAC,CAAC;QACL,CAAC;QAEQ,iBAAiB;YACxB,KAAK,CAAC,iBAAiB,EAAE,CAAC;YAC1B,oEAAoE;YACpE,wDAAwD;YACxD,IAAI,CAAC,aAAa,EAAE,CAAC;QACvB,CAAC;QAEQ,oBAAoB;;YAC3B,KAAK,CAAC,oBAAoB,EAAE,CAAC;YAC7B,MAAA,IAAI,CAAC,SAAS,oDAAI,CAAC;QACrB,CAAC;KACF;IACD,OAAO,aAAa,CAAC;AACvB,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport type {ReactiveElement} from 'lit';\nimport {effect} from '@preact/signals-core';\n\ntype ReactiveElementConstructor = abstract new (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...args: any[]\n) => ReactiveElement;\n\n/**\n * Adds the ability for a LitElement or other ReactiveElement class to\n * watch for access to Preact signals during the update lifecycle and\n * trigger a new update when signals values change.\n */\nexport function SignalWatcher<T extends ReactiveElementConstructor>(\n  Base: T\n): T {\n  abstract class SignalWatcher extends Base {\n    private __dispose?: () => void;\n\n    override performUpdate() {\n      // ReactiveElement.performUpdate() also does this check, so we want to\n      // also bail early so we don't erroneously appear to not depend on any\n      // signals.\n      if (this.isUpdatePending === false) {\n        return;\n      }\n      // If we have a previous effect, dispose it\n      this.__dispose?.();\n\n      // Tracks whether the effect callback is triggered by this performUpdate\n      // call directly, or by a signal change.\n      let updateFromLit = true;\n\n      // We create a new effect to capture all signal access within the\n      // performUpdate phase (update, render, updated, etc) of the element.\n      // Q: Do we need to create a new effect each render?\n      // TODO: test various combinations of render triggers:\n      //  - from requestUpdate()\n      //  - from signals\n      //  - from both (do we get one or two re-renders)\n      // and see if we really need a new effect here.\n      this.__dispose = effect(() => {\n        if (updateFromLit) {\n          updateFromLit = false;\n          super.performUpdate();\n        } else {\n          // This branch is an effect run from Preact signals.\n          // This will cause another call into performUpdate, which will\n          // then create a new effect watching that update pass.\n          this.requestUpdate();\n        }\n      });\n    }\n\n    override connectedCallback(): void {\n      super.connectedCallback();\n      // In order to listen for signals again after re-connection, we must\n      // re-render to capture all the current signal accesses.\n      this.requestUpdate();\n    }\n\n    override disconnectedCallback(): void {\n      super.disconnectedCallback();\n      this.__dispose?.();\n    }\n  }\n  return SignalWatcher;\n}\n"]}