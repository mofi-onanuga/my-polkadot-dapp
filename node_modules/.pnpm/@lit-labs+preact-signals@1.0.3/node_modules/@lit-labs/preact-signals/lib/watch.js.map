{"version":3,"file":"watch.js","sources":["../src/lib/watch.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {directive} from 'lit/directive.js';\nimport {AsyncDirective} from 'lit/async-directive.js';\nimport {type Signal} from '@preact/signals-core';\n\nclass WatchDirective extends AsyncDirective {\n  private __signal?: Signal;\n  private __dispose?: () => void;\n\n  override render(signal: Signal<unknown>) {\n    if (signal !== this.__signal) {\n      this.__dispose?.();\n      this.__signal = signal;\n\n      // Whether the subscribe() callback is called because of this render\n      // pass, or because of a separate signal update.\n      let updateFromLit = true;\n      this.__dispose = signal.subscribe((value) => {\n        // The subscribe() callback is called synchronously during subscribe.\n        // Ignore the first call since we return the value below in that case.\n        if (updateFromLit === false) {\n          this.setValue(value);\n        }\n      });\n      updateFromLit = false;\n    }\n\n    // We use peek() so that the signal access is not tracked by the effect\n    // created by SignalWatcher.performUpdate(). This means that a signal\n    // update won't trigger a full element update if it's only passed to\n    // watch() and not otherwise accessed by the element.\n    return signal.peek();\n  }\n\n  protected override disconnected(): void {\n    this.__dispose?.();\n  }\n\n  protected override reconnected(): void {\n    // Since we disposed the subscription in disconnected() we need to\n    // resubscribe here. We don't ignore the synchronous callback call because\n    // the signal might have changed while the directive is disconnected.\n    //\n    // There are two possible reasons for a disconnect:\n    //   1. The host element was disconnected.\n    //   2. The directive was not rendered during a render\n    // In the first case the element will not schedule an update on reconnect,\n    // so we need the synchronous call here to set the current value.\n    // In the second case, we're probably reconnecting *because* of a render,\n    // so the synchronous call here will go before a render call, and we'll get\n    // two sets of the value (setValue() here and the return in render()), but\n    // this is ok because the value will be dirty-checked by lit-html.\n    this.__dispose = this.__signal?.subscribe((value) => {\n      this.setValue(value);\n    });\n  }\n}\n\n/**\n * Renders a signal and subscribes to it, updating the part when the signal\n * changes.\n */\nexport const watch = directive(WatchDirective);\n"],"names":["watch","directive","AsyncDirective","render","signal","this","__signal","_a","__dispose","call","updateFromLit","subscribe","value","setValue","peek","disconnected","reconnected"],"mappings":";;;;;SAmEaA,EAAQC,EAzDrB,cAA6BC,EAIlB,MAAAC,CAAOC,SACd,GAAIA,IAAWC,KAAKC,KAAU,CACd,QAAdC,EAAAF,KAAKG,YAAS,IAAAD,GAAAA,EAAAE,KAAAJ,MACdA,KAAKC,KAAWF,EAIhB,IAAIM,GAAgB,EACpBL,KAAKG,KAAYJ,EAAOO,WAAWC,KAGX,IAAlBF,GACFL,KAAKQ,SAASD,EACf,IAEHF,GAAgB,CACjB,CAMD,OAAON,EAAOU,MACf,CAEkB,YAAAC,SACH,QAAdR,EAAAF,KAAKG,YAAS,IAAAD,GAAAA,EAAAE,KAAAJ,KACf,CAEkB,WAAAW,SAcjBX,KAAKG,KAAyB,QAAbD,EAAAF,KAAKC,YAAQ,IAAAC,OAAA,EAAAA,EAAEI,WAAWC,IACzCP,KAAKQ,SAASD,EAAM,GAEvB"}