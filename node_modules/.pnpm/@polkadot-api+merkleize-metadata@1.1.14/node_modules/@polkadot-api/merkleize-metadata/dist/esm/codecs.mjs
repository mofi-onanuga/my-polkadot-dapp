import { Struct, str, u8, u16, u32, Bytes, ScaleEnum, _void, compactNumber, Option, Vector, bool, enhanceDecoder, Tuple, compact } from '@polkadot-api/substrate-bindings';

const extraInfoInner = {
  specVersion: u32,
  specName: str,
  base58Prefix: u16,
  decimals: u8,
  tokenSymbol: str
};
const extraInfo = Struct(extraInfoInner);
const hash = Bytes(32);
const metadataDigest = ScaleEnum({
  V0: _void,
  V1: Struct({
    typeInformationTreeRoot: hash,
    extrinsicMetadataHash: hash,
    ...extraInfoInner
  })
});
ScaleEnum({
  bool: _void,
  char: _void,
  str: _void,
  u8: _void,
  u16: _void,
  u32: _void,
  u64: _void,
  u128: _void,
  u256: _void,
  i8: _void,
  i16: _void,
  i32: _void,
  i64: _void,
  i128: _void,
  i256: _void
});
const typeRef = ScaleEnum({
  bool: _void,
  char: _void,
  str: _void,
  u8: _void,
  u16: _void,
  u32: _void,
  u64: _void,
  u128: _void,
  u256: _void,
  i8: _void,
  i16: _void,
  i32: _void,
  i64: _void,
  i128: _void,
  i256: _void,
  compactU8: _void,
  compactU16: _void,
  compactU32: _void,
  compactU64: _void,
  compactU128: _void,
  compactU256: _void,
  void: _void,
  perId: compactNumber
});
const field = Struct({
  name: Option(str),
  ty: typeRef,
  typeName: Option(str)
});
const typeDef = ScaleEnum({
  composite: Vector(field),
  enumeration: Struct({
    name: str,
    fields: Vector(field),
    index: compactNumber
  }),
  sequence: typeRef,
  array: Struct({
    len: u32,
    typeParam: typeRef
  }),
  tuple: Vector(typeRef),
  bitSequence: Struct({
    numBytes: u8,
    leastSignificantBitFirst: bool
  })
});
const lookupType = Struct({
  path: Vector(str),
  typeDef,
  typeId: compactNumber
});
const lookup = Vector(lookupType);
const extrinsicMetadata = Struct({
  version: u8,
  addressTy: typeRef,
  callTy: typeRef,
  signatureTy: typeRef,
  signedExtensions: Vector(
    Struct({
      identifier: str,
      includedInExtrinsic: typeRef,
      includedInSignedData: typeRef
    })
  )
});
const versionDecoder = enhanceDecoder(u8[1], (value) => ({
  version: value & -129,
  signed: !!(value & 1 << 7)
}));
const extrinsicDec = Tuple.dec(
  compact[1],
  versionDecoder,
  Bytes(Infinity)[1]
);
const proof = Struct({
  leaves: lookup,
  leafIdxs: Vector(u32),
  proofs: Vector(hash),
  extrinsic: extrinsicMetadata,
  info: extraInfo
});

export { extraInfo, extrinsicDec, extrinsicMetadata, hash, lookup, lookupType, metadataDigest, proof, typeDef, typeRef };
//# sourceMappingURL=codecs.mjs.map
