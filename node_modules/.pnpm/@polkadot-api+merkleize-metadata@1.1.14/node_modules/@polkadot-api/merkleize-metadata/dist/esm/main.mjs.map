{"version":3,"file":"main.mjs","sources":["../../src/main.ts"],"sourcesContent":["import {\n  Blake3256,\n  HexString,\n  compact,\n  u32,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  ExtraInfo,\n  ExtrinsicMetadata,\n  LookupValue,\n  MetadataDigest,\n  ScalePrimitive,\n  TypeRef,\n  extraInfo,\n  extrinsicMetadata,\n  lookupType,\n  metadataDigest,\n  extrinsicDec,\n} from \"./codecs\"\nimport { getAccessibleTypes } from \"./get-accessible-types\"\nimport { getLookup } from \"./get-lookup\"\nimport { getMetadata } from \"./get-metadata\"\nimport { compactTypeRefs, mergeUint8, toBytes } from \"./utils\"\nimport { decodeAndCollectKnownLeafs } from \"./decode-and-collect\"\nimport { getProofData } from \"./proof\"\nimport { getDynamicBuilder, getLookupFn } from \"@polkadot-api/metadata-builders\"\n\nexport interface MetadataMerkleizer {\n  /**\n   * @returns Digest value of the metadata (aka its merkleized root-hash)\n   */\n  digest: () => Uint8Array\n\n  /**\n   * Get proof for an `Extrinsic`.\n   *\n   * @param transaction         Encoded `Extrinsic`, both signed or unsigned.\n   * @param txAdditionalSigned  Optionally collect types for given\n   *                            `additionalSigned` part of signedExtensions.\n   * @returns Encoded `Proof`\n   */\n  getProofForExtrinsic: (\n    transaction: Uint8Array | HexString,\n    txAdditionalSigned?: Uint8Array | HexString,\n  ) => Uint8Array\n\n  /**\n   * Get proof for `ExtrinsicPayload` parts.\n   *\n   * @param callData              Call data of the transaction. It has to be\n   *                              bare; i.e.\n   *                              without prepended compact length.\n   * @param includedInExtrinsic   Extra part of the signed extensions, all of\n   *                              them concatenated.\n   * @param includedInSignedData  Additional signed part of the signed\n   *                              extensions, all of them concatenated.\n   * @returns Encoded `Proof`\n   */\n  getProofForExtrinsicParts: (\n    callData: Uint8Array | HexString,\n    includedInExtrinsic: Uint8Array | HexString,\n    includedInSignedData: Uint8Array | HexString,\n  ) => Uint8Array\n\n  /**\n   * Get proof for `ExtrinsicPayload`.\n   *\n   * @param extrinsicPayload  Call data, extra part of signedExtensions and\n   *                          additional signed part of signedExtensions\n   *                          concatenated. It has to be bare; i.e. without\n   *                          prepended compact length.\n   * @returns Encoded `Proof`\n   */\n  getProofForExtrinsicPayload: (\n    extrinsicPayload: Uint8Array | HexString,\n  ) => Uint8Array\n}\n\nconst assertExpected = <T>(name: string, expected: T, received?: T): void => {\n  if (received != null && received !== expected)\n    throw new Error(\n      `${name} not expected. Received ${received} expected ${expected}`,\n    )\n}\n\nexport const merkleizeMetadata = (\n  metadataBytes: Uint8Array | HexString,\n  {\n    decimals,\n    tokenSymbol,\n    ...hinted\n  }: { decimals: number; tokenSymbol: string } & Partial<ExtraInfo>,\n): MetadataMerkleizer => {\n  const metadata = getMetadata(metadataBytes)\n  const { ss58Prefix, buildDefinition } = getDynamicBuilder(\n    getLookupFn(metadata),\n  )\n  if (ss58Prefix == null) throw new Error(\"SS58 prefix not found in metadata\")\n  assertExpected(\"SS58 prefix\", ss58Prefix, hinted.base58Prefix)\n  const version = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"Version\")\n  if (version == null) throw new Error(\"System.Version constant not found\")\n  const { spec_name: specName, spec_version: specVersion } = buildDefinition(\n    version.type,\n  ).dec(version.value)\n  if (typeof specName !== \"string\" || typeof specVersion !== \"number\")\n    throw new Error(\"Spec name or spec version not found\")\n  assertExpected(\"Spec name\", specName, hinted.specName)\n  assertExpected(\"Spec version\", specVersion, hinted.specVersion)\n\n  const info: ExtraInfo = {\n    decimals,\n    tokenSymbol,\n    specVersion,\n    specName,\n    base58Prefix: ss58Prefix,\n  }\n  const definitions = new Map<number, LookupValue>(\n    metadata.lookup.map((value) => [value.id, value]),\n  )\n  const accessibleTypes = getAccessibleTypes(metadata, definitions)\n  const getPrimitive = (frameId: number): ScalePrimitive[\"tag\"] | null => {\n    const {\n      def: { tag, value },\n    } = definitions.get(frameId)!\n\n    if (tag === \"primitive\") return value.tag\n\n    if ((tag !== \"composite\" && tag !== \"tuple\") || value.length > 1)\n      throw new Error(\"The provided definition doesn't map to a primitive\")\n\n    return value.length === 0\n      ? null // signals `void`\n      : getPrimitive(tag === \"tuple\" ? value[0] : value[0].type)\n  }\n\n  const getTypeRef = (frameId: number): TypeRef => {\n    const { def } = definitions.get(frameId)!\n\n    if (def.tag === \"primitive\") return { tag: def.value.tag, value: undefined }\n\n    if (def.tag === \"compact\") {\n      const primitive = getPrimitive(def.value)\n      const tag = compactTypeRefs[primitive as \"u8\"]\n      if (!tag) throw new Error(\"Invalid primitive for Compact\")\n      return { tag, value: undefined }\n    }\n\n    return accessibleTypes.has(frameId)\n      ? { tag: \"perId\", value: accessibleTypes.get(frameId)! }\n      : { tag: \"void\", value: undefined }\n  }\n\n  const extrinsic: ExtrinsicMetadata = {\n    version: metadata.extrinsic.version,\n    addressTy: getTypeRef(metadata.extrinsic.address),\n    callTy: getTypeRef(metadata.extrinsic.call),\n    signatureTy: getTypeRef(metadata.extrinsic.signature),\n    signedExtensions: metadata.extrinsic.signedExtensions.map((se) => ({\n      identifier: se.identifier,\n      includedInExtrinsic: getTypeRef(se.type),\n      includedInSignedData: getTypeRef(se.additionalSigned),\n    })),\n  }\n\n  const lookup = getLookup(\n    definitions,\n    accessibleTypes,\n    getTypeRef,\n    getPrimitive,\n  )\n  const lookupEncoded = lookup.map(lookupType.enc)\n\n  let hashTree: Array<Uint8Array> | undefined\n  const getHashTree = (): Array<Uint8Array> => {\n    if (hashTree) return hashTree\n\n    if (!lookupEncoded.length) return (hashTree = [new Uint8Array(32).fill(0)])\n\n    hashTree = new Array(lookupEncoded.length * 2 - 1)\n\n    let leavesStartIdx = lookupEncoded.length - 1\n    for (let i = 0; i < lookupEncoded.length; i++)\n      hashTree[leavesStartIdx + i] = Blake3256(lookupEncoded[i])\n\n    for (let i = hashTree.length - 2; i > 0; i -= 2)\n      hashTree[(i - 1) / 2] = Blake3256(\n        mergeUint8([hashTree[i], hashTree[i + 1]]),\n      )\n\n    return hashTree\n  }\n\n  let digested: undefined | Uint8Array\n  const digest = () => {\n    if (digested) return digested\n    const rootLookupHash = getHashTree()[0]\n\n    const digest: MetadataDigest = {\n      tag: \"V1\",\n      value: {\n        typeInformationTreeRoot: rootLookupHash,\n        extrinsicMetadataHash: Blake3256(extrinsicMetadata.enc(extrinsic)),\n        ...info,\n      },\n    }\n\n    return (digested = Blake3256(metadataDigest.enc(digest)))\n  }\n\n  const generateProof = (knownIndexes: number[]) => {\n    const proofData = getProofData(lookupEncoded, knownIndexes)\n\n    const hashTree = getHashTree()\n    const proofs = proofData.proofIdxs.map((idx) => hashTree[idx])\n\n    return mergeUint8([\n      compact.enc(proofData.leaves.length),\n      ...proofData.leaves,\n      compact.enc(proofData.leafIdxs.length),\n      ...proofData.leafIdxs.map((x) => u32.enc(x)),\n      compact.enc(proofs.length),\n      ...proofs,\n      extrinsicMetadata.enc(extrinsic),\n      extraInfo.enc(info),\n    ])\n  }\n\n  const getProofForExtrinsicPayload = (\n    extrinsicPayload: Uint8Array | HexString,\n  ) => {\n    const typeRefs: Array<TypeRef> = [\n      extrinsic.callTy,\n      ...extrinsic.signedExtensions.map((x) => x.includedInExtrinsic),\n      ...extrinsic.signedExtensions.map((x) => x.includedInSignedData),\n    ]\n    return generateProof(\n      decodeAndCollectKnownLeafs(extrinsicPayload, typeRefs, lookup),\n    )\n  }\n\n  const getProofForExtrinsicParts = (\n    callData: Uint8Array | HexString,\n    includedInExtrinsic: Uint8Array | HexString,\n    includedInSignedData: Uint8Array | HexString,\n  ) => {\n    const bytes = mergeUint8(\n      [callData, includedInExtrinsic, includedInSignedData].map(toBytes),\n    )\n    return getProofForExtrinsicPayload(bytes)\n  }\n\n  const getProofForExtrinsic = (\n    transaction: Uint8Array | HexString,\n    txAdditionalSigned?: Uint8Array | HexString,\n  ) => {\n    let [, { version, signed }, bytes] = extrinsicDec(transaction)\n\n    if (version !== extrinsic.version)\n      throw new Error(\"Incorrect extrinsic version\")\n\n    const typeRefs: TypeRef[] = signed\n      ? [\n          extrinsic.addressTy,\n          extrinsic.signatureTy,\n          ...extrinsic.signedExtensions.map((x) => x.includedInExtrinsic),\n          extrinsic.callTy,\n        ]\n      : [extrinsic.callTy]\n\n    if (txAdditionalSigned) {\n      bytes = mergeUint8([bytes, toBytes(txAdditionalSigned)])\n      typeRefs.push(\n        ...extrinsic.signedExtensions.map((x) => x.includedInSignedData),\n      )\n    }\n\n    return generateProof(decodeAndCollectKnownLeafs(bytes, typeRefs, lookup))\n  }\n\n  return {\n    digest,\n    getProofForExtrinsic,\n    getProofForExtrinsicParts,\n    getProofForExtrinsicPayload,\n  }\n}\n"],"names":["digest","hashTree","version"],"mappings":"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"}