import { createDecoder, compact, _void, i256, i128, i64, i32, i16, i8, u256, u128, u64, u32, u16, u8, str } from '@polkadot-api/substrate-bindings';

const typeRefDecoders = {
  bool: u8,
  char: u8,
  str,
  u8,
  u16,
  u32,
  u64,
  u128,
  u256,
  i8,
  i16,
  i32,
  i64,
  i128,
  i256,
  void: _void,
  compactU8: compact,
  compactU16: compact,
  compactU32: compact,
  compactU64: compact,
  compactU128: compact,
  compactU256: compact
};
const innerDecodeAndCollect = (input, typeRef, idToLookups, lookup, collected) => {
  if (typeRef.tag !== "perId") {
    typeRefDecoders[typeRef.tag][1](input);
    return;
  }
  const handleTypeRef = (typeRef2) => {
    innerDecodeAndCollect(input, typeRef2, idToLookups, lookup, collected);
  };
  const lookupIdxs = idToLookups.get(typeRef.value);
  const [currentIdx] = lookupIdxs;
  const current = lookup[currentIdx];
  if (lookupIdxs.length === 1) collected.add(currentIdx);
  switch (current.typeDef.tag) {
    case "enumeration": {
      const selectedIdx = u8.dec(input);
      const [selected, collectedIdx] = lookupIdxs.map(
        (lookupIdx) => [lookup[lookupIdx].typeDef, lookupIdx]
      ).find(([x]) => x.value.index === selectedIdx);
      collected.add(collectedIdx);
      selected.value.fields.forEach(({ ty }) => {
        handleTypeRef(ty);
      });
      break;
    }
    case "sequence": {
      const len = compact.dec(input);
      for (let i = 0; i < len; i++) handleTypeRef(current.typeDef.value);
      break;
    }
    case "array": {
      for (let i = 0; i < current.typeDef.value.len; i++)
        handleTypeRef(current.typeDef.value.typeParam);
      break;
    }
    case "composite": {
      current.typeDef.value.forEach((x) => {
        handleTypeRef(x.ty);
      });
      break;
    }
    case "tuple": {
      current.typeDef.value.forEach(handleTypeRef);
      break;
    }
    case "bitSequence":
      throw new Error("bitSequence is not supported");
  }
};
const decodeAndCollectKnownLeafs = (data, typeRefs, lookup) => {
  let input = new Uint8Array();
  createDecoder((_input) => {
    input = _input;
  })(data);
  const idToLookups = /* @__PURE__ */ new Map();
  lookup.forEach((lookup2, idx) => {
    const arr = idToLookups.get(lookup2.typeId);
    if (arr) arr.push(idx);
    else idToLookups.set(lookup2.typeId, [idx]);
  });
  const result = /* @__PURE__ */ new Set();
  typeRefs.forEach((typeRef) => {
    innerDecodeAndCollect(input, typeRef, idToLookups, lookup, result);
  });
  return [...result].sort((a, b) => a - b);
};

export { decodeAndCollectKnownLeafs };
//# sourceMappingURL=decode-and-collect.mjs.map
