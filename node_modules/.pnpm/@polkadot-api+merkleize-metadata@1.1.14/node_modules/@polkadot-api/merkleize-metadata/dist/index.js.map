{"version":3,"file":"index.js","sources":["../src/codecs.ts","../src/get-accessible-types.ts","../src/get-lookup.ts","../src/get-metadata.ts","../src/utils.ts","../src/decode-and-collect.ts","../src/proof.ts","../src/main.ts"],"sourcesContent":["import {\n  Bytes,\n  Codec,\n  CodecType,\n  Option,\n  ScaleEnum,\n  Struct,\n  Tuple,\n  V15,\n  Vector,\n  _void,\n  bool,\n  compact,\n  compactNumber,\n  enhanceDecoder,\n  str,\n  u16,\n  u32,\n  u8,\n} from \"@polkadot-api/substrate-bindings\"\n\nconst extraInfoInner = {\n  specVersion: u32,\n  specName: str,\n  base58Prefix: u16,\n  decimals: u8,\n  tokenSymbol: str,\n}\nexport const extraInfo = Struct(extraInfoInner)\nexport type ExtraInfo = CodecType<typeof extraInfo>\n\nexport const hash = Bytes(32)\nexport const metadataDigest = ScaleEnum({\n  V0: _void,\n  V1: Struct({\n    typeInformationTreeRoot: hash,\n    extrinsicMetadataHash: hash,\n    ...extraInfoInner,\n  }),\n})\nexport type MetadataDigest = CodecType<typeof metadataDigest>\n\nexport const scalePrimitive = ScaleEnum({\n  bool: _void,\n  char: _void,\n  str: _void,\n  u8: _void,\n  u16: _void,\n  u32: _void,\n  u64: _void,\n  u128: _void,\n  u256: _void,\n  i8: _void,\n  i16: _void,\n  i32: _void,\n  i64: _void,\n  i128: _void,\n  i256: _void,\n})\nexport type ScalePrimitive = CodecType<typeof scalePrimitive>\n\nexport const typeRef = ScaleEnum({\n  bool: _void,\n  char: _void,\n  str: _void,\n  u8: _void,\n  u16: _void,\n  u32: _void,\n  u64: _void,\n  u128: _void,\n  u256: _void,\n  i8: _void,\n  i16: _void,\n  i32: _void,\n  i64: _void,\n  i128: _void,\n  i256: _void,\n  compactU8: _void,\n  compactU16: _void,\n  compactU32: _void,\n  compactU64: _void,\n  compactU128: _void,\n  compactU256: _void,\n  void: _void,\n  perId: compactNumber,\n})\nexport type TypeRef = CodecType<typeof typeRef>\n\nconst field = Struct({\n  name: Option(str),\n  ty: typeRef,\n  typeName: Option(str),\n})\nexport const typeDef = ScaleEnum({\n  composite: Vector(field),\n  enumeration: Struct({\n    name: str,\n    fields: Vector(field),\n    index: compactNumber,\n  }),\n  sequence: typeRef,\n  array: Struct({\n    len: u32,\n    typeParam: typeRef,\n  }),\n  tuple: Vector(typeRef),\n  bitSequence: Struct({\n    numBytes: u8,\n    leastSignificantBitFirst: bool,\n  }),\n})\nexport type TypeDef = CodecType<typeof typeDef>\n\nexport const lookupType = Struct({\n  path: Vector(str),\n  typeDef: typeDef,\n  typeId: compactNumber,\n})\nexport type LookupEntry = CodecType<typeof lookupType>\nexport type Lookup = Array<LookupEntry>\nexport const lookup: Codec<Lookup> = Vector(lookupType)\n\nexport const extrinsicMetadata = Struct({\n  version: u8,\n  addressTy: typeRef,\n  callTy: typeRef,\n  signatureTy: typeRef,\n  signedExtensions: Vector(\n    Struct({\n      identifier: str,\n      includedInExtrinsic: typeRef,\n      includedInSignedData: typeRef,\n    }),\n  ),\n})\nexport type ExtrinsicMetadata = CodecType<typeof extrinsicMetadata>\nexport type LookupValue = V15[\"lookup\"] extends Array<infer T> ? T : never\n\nconst versionDecoder = enhanceDecoder(u8[1], (value) => ({\n  version: value & ~(1 << 7),\n  signed: !!(value & (1 << 7)),\n}))\n\nexport const extrinsicDec = Tuple.dec(\n  compact[1],\n  versionDecoder,\n  Bytes(Infinity)[1],\n)\n\nexport const proof = Struct({\n  leaves: lookup,\n  leafIdxs: Vector(u32),\n  proofs: Vector(hash),\n  extrinsic: extrinsicMetadata,\n  info: extraInfo,\n})\nexport type Proof = CodecType<typeof proof>\n","import { V15 } from \"@polkadot-api/substrate-bindings\"\nimport { LookupValue } from \"./codecs\"\n\nexport const getAccessibleTypes = (\n  metadata: V15,\n  definitions: Map<number, LookupValue>,\n): Map<number, number> => {\n  const types = new Set<number>()\n\n  const collectTypesFromId = (id: number) => {\n    if (types.has(id)) return\n\n    const { tag, value } = definitions.get(id)!.def\n    switch (tag) {\n      case \"composite\":\n        if (!value.length) break\n        types.add(id)\n        value.forEach(({ type }) => {\n          collectTypesFromId(type)\n        })\n        break\n      case \"variant\":\n        if (!value.length) break\n        types.add(id)\n        value.forEach(({ fields }) => {\n          fields.forEach(({ type }) => {\n            collectTypesFromId(type)\n          })\n        })\n        break\n      case \"tuple\":\n        if (!value.length) break\n        types.add(id)\n        value.forEach(collectTypesFromId)\n        break\n      case \"sequence\":\n        types.add(id)\n        collectTypesFromId(value)\n        break\n      case \"array\":\n        types.add(id)\n        collectTypesFromId(value.type)\n        break\n      case \"bitSequence\": // bitSequence inner types are not stored\n        types.add(id)\n      // primitive and compact are not stored\n    }\n  }\n\n  collectTypesFromId(metadata.extrinsic.call)\n  collectTypesFromId(metadata.extrinsic.address)\n  collectTypesFromId(metadata.extrinsic.signature)\n  metadata.extrinsic.signedExtensions.forEach(({ type, additionalSigned }) => {\n    collectTypesFromId(type)\n    collectTypesFromId(additionalSigned)\n  })\n\n  const sortedTypes = [...types].sort((a, b) => a - b)\n  return new Map(sortedTypes.map((value, idx) => [value, idx]))\n}\n","import { Lookup, LookupValue, ScalePrimitive, TypeDef, TypeRef } from \"./codecs\"\n\nconst bitSequenceBytes = {\n  u8: 1,\n  u16: 2,\n  u32: 4,\n  u64: 8,\n}\n\nconst constructTypeDef = (\n  definitions: Map<number, LookupValue>,\n  getTypeRef: (frameId: number) => TypeRef,\n  getPrimitive: (frameId: number) => ScalePrimitive[\"tag\"] | null,\n  frameId: number,\n): TypeDef[] => {\n  const {\n    def: { tag, value },\n  } = definitions.get(frameId)!\n  switch (tag) {\n    case \"composite\":\n      return [\n        {\n          tag,\n          value: value.map((f) => ({\n            name: f.name,\n            typeName: f.typeName,\n            ty: getTypeRef(f.type),\n          })),\n        },\n      ]\n    case \"variant\": {\n      return value.map((v) => ({\n        tag: \"enumeration\",\n        value: {\n          name: v.name,\n          index: v.index,\n          fields: v.fields.map((f) => ({\n            name: f.name,\n            typeName: f.typeName,\n            ty: getTypeRef(f.type),\n          })),\n        },\n      }))\n    }\n    case \"sequence\":\n      return [\n        {\n          tag,\n          value: getTypeRef(value),\n        },\n      ]\n    case \"array\":\n      return [\n        {\n          tag,\n          value: {\n            len: value.len,\n            typeParam: getTypeRef(value.type),\n          },\n        },\n      ]\n    case \"tuple\":\n      return [\n        {\n          tag,\n          value: value.map(getTypeRef),\n        },\n      ]\n    case \"bitSequence\": {\n      const primitive = getPrimitive(value.bitStoreType)\n      const numBytes = bitSequenceBytes[primitive as \"u8\"]\n      if (!numBytes) throw new Error(\"Invalid primitive for BitSequence\")\n\n      const storeOrderPath = definitions.get(value.bitOrderType)!.path\n      const leastSignificantBitFirst = storeOrderPath.includes(\"Lsb0\")\n      if (!leastSignificantBitFirst && !storeOrderPath.includes(\"Msb0\"))\n        throw new Error(\"BitOrderType not recognized\")\n\n      return [\n        {\n          tag: \"bitSequence\",\n          value: { numBytes, leastSignificantBitFirst },\n        },\n      ]\n    }\n  }\n\n  throw new Error(`FrameId(${frameId}) should have been filtered out`)\n}\n\nexport const getLookup = (\n  definitions: Map<number, LookupValue>,\n  accessibleTypes: Map<number, number>,\n  getTypeRef: (frameId: number) => TypeRef,\n  getPrimitive: (frameId: number) => ScalePrimitive[\"tag\"] | null,\n) => {\n  const typeTree: Lookup = []\n  ;[...accessibleTypes.entries()].forEach(([frameId, typeId]) => {\n    const { path } = definitions.get(frameId)!\n    constructTypeDef(definitions, getTypeRef, getPrimitive, frameId).forEach(\n      (typeDef) => {\n        typeTree.push({\n          path,\n          typeId,\n          typeDef,\n        })\n      },\n    )\n  })\n\n  typeTree.sort((a, b) => {\n    if (a.typeId !== b.typeId) return a.typeId - b.typeId // in general\n    // should only happen for variants\n    if (a.typeDef.tag !== \"enumeration\" || b.typeDef.tag !== \"enumeration\")\n      throw new Error(\"Found two types with same id\")\n    return a.typeDef.value.index - b.typeDef.value.index\n  })\n  return typeTree\n}\n","import {\n  decAnyMetadata,\n  type HexString,\n  type V15,\n} from \"@polkadot-api/substrate-bindings\"\n\nexport const getMetadata = (input: Uint8Array | HexString): V15 => {\n  try {\n    const { metadata } = decAnyMetadata(input)\n    if (metadata.tag !== \"v15\") throw new Error(\"Wrong metadata version\")\n    return metadata.value\n  } catch (e) {\n    throw e || new Error(\"Unable to decode metadata\")\n  }\n}\n","import { type HexString } from \"@polkadot-api/substrate-bindings\"\nimport { fromHex } from \"@polkadot-api/utils\"\n\nexport const mergeUint8 = (inputs: Array<Uint8Array>): Uint8Array => {\n  const len = inputs.length\n  let totalLen = 0\n  for (let i = 0; i < len; i++) totalLen += inputs[i].byteLength\n  const result = new Uint8Array(totalLen)\n\n  for (let idx = 0, at = 0; idx < len; idx++) {\n    const current = inputs[idx]\n    result.set(current, at)\n    at += current.byteLength\n  }\n\n  return result\n}\n\nexport const toBytes = (input: Uint8Array | HexString) =>\n  typeof input === \"string\" ? fromHex(input) : input\n\nexport const compactTypeRefs = {\n  null: \"void\" as const,\n  u8: \"compactU8\" as const,\n  u16: \"compactU16\" as const,\n  u32: \"compactU32\" as const,\n  u64: \"compactU64\" as const,\n  u128: \"compactU128\" as const,\n  u256: \"compactU256\" as const,\n}\n","import {\n  HexString,\n  _void,\n  compact,\n  createDecoder,\n  i128,\n  i16,\n  i256,\n  i32,\n  i64,\n  i8,\n  str,\n  u128,\n  u16,\n  u256,\n  u32,\n  u64,\n  u8,\n} from \"@polkadot-api/substrate-bindings\"\nimport { Lookup, TypeDef, TypeRef } from \"./codecs\"\n\nconst typeRefDecoders = {\n  bool: u8,\n  char: u8,\n  str,\n  u8,\n  u16,\n  u32,\n  u64,\n  u128,\n  u256,\n  i8,\n  i16,\n  i32,\n  i64,\n  i128,\n  i256,\n  void: _void,\n  compactU8: compact,\n  compactU16: compact,\n  compactU32: compact,\n  compactU64: compact,\n  compactU128: compact,\n  compactU256: compact,\n}\n\nconst innerDecodeAndCollect = (\n  input: Uint8Array,\n  typeRef: TypeRef,\n  idToLookups: Map<number, Array<number>>,\n  lookup: Lookup,\n  collected: Set<number>,\n) => {\n  if (typeRef.tag !== \"perId\") {\n    typeRefDecoders[typeRef.tag][1](input)\n    return\n  }\n\n  const handleTypeRef = (typeRef: TypeRef) => {\n    innerDecodeAndCollect(input, typeRef, idToLookups, lookup, collected)\n  }\n\n  const lookupIdxs = idToLookups.get(typeRef.value)!\n  const [currentIdx] = lookupIdxs\n  const current = lookup[currentIdx]\n\n  if (lookupIdxs.length === 1) collected.add(currentIdx)\n\n  switch (current.typeDef.tag) {\n    case \"enumeration\": {\n      const selectedIdx = u8.dec(input)\n      const [selected, collectedIdx] = lookupIdxs\n        .map(\n          (lookupIdx) =>\n            [lookup[lookupIdx].typeDef, lookupIdx] as [\n              TypeDef & { tag: \"enumeration\" },\n              number,\n            ],\n        )\n        .find(([x]) => x.value.index === selectedIdx)!\n      collected.add(collectedIdx)\n      selected.value.fields.forEach(({ ty }) => {\n        handleTypeRef(ty)\n      })\n      break\n    }\n    case \"sequence\": {\n      const len = compact.dec(input)\n      for (let i = 0; i < len; i++) handleTypeRef(current.typeDef.value)\n      break\n    }\n    case \"array\": {\n      for (let i = 0; i < current.typeDef.value.len; i++)\n        handleTypeRef(current.typeDef.value.typeParam)\n      break\n    }\n    case \"composite\": {\n      current.typeDef.value.forEach((x) => {\n        handleTypeRef(x.ty)\n      })\n      break\n    }\n    case \"tuple\": {\n      current.typeDef.value.forEach(handleTypeRef)\n      break\n    }\n    case \"bitSequence\":\n      throw new Error(\"bitSequence is not supported\")\n  }\n}\n\nexport const decodeAndCollectKnownLeafs = (\n  data: Uint8Array | HexString,\n  typeRefs: Array<TypeRef>,\n  lookup: Lookup,\n): Array<number> => {\n  let input = new Uint8Array()\n  createDecoder((_input) => {\n    input = _input\n  })(data)\n\n  const idToLookups = new Map<number, number[]>()\n  lookup.forEach((lookup, idx) => {\n    const arr = idToLookups.get(lookup.typeId)\n    if (arr) arr.push(idx)\n    else idToLookups.set(lookup.typeId, [idx])\n  })\n\n  const result = new Set<number>()\n  typeRefs.forEach((typeRef) => {\n    innerDecodeAndCollect(input, typeRef, idToLookups, lookup, result)\n  })\n\n  return [...result].sort((a, b) => a - b)\n}\n","const getLevelFromIdx = (idx: number) => Math.log2(idx + 1) | 0\nconst getAncestorIdx = (from: number, nLevels: number) =>\n  ((from + 1) >> nLevels) - 1\n\nexport function getProofData(\n  leaves: Array<Uint8Array>,\n  knownLeavesIdxs: Array<number>,\n) {\n  const knownLeaves = knownLeavesIdxs.map((idx) => leaves[idx])\n\n  const startingIdx = leaves.length - 1\n  const leafIdxs = knownLeavesIdxs.map((idx) => startingIdx + idx)\n\n  const proofIdxs: Array<number> = []\n  if (leafIdxs.length) {\n    const nLevels = getLevelFromIdx(leafIdxs.at(-1)!)\n    const splitPosition = Math.pow(2, nLevels) - 1\n    const splitIdx = leafIdxs.findIndex((x) => x >= splitPosition)\n    if (splitIdx > 0) {\n      leafIdxs.unshift(...leafIdxs.splice(splitIdx))\n      knownLeaves.unshift(...knownLeaves.splice(splitIdx))\n    }\n  }\n\n  let targetIdx = 0\n  const traverse = (nodeIdx: number): void => {\n    if (targetIdx === leafIdxs.length) {\n      proofIdxs.push(nodeIdx)\n      return\n    }\n\n    const target = leafIdxs[targetIdx]\n    if (target === nodeIdx) {\n      ++targetIdx\n      return\n    }\n\n    const currentLevel = getLevelFromIdx(nodeIdx)\n    const targetLevel = getLevelFromIdx(target)\n\n    if (nodeIdx !== getAncestorIdx(target, targetLevel - currentLevel)) {\n      proofIdxs.push(nodeIdx)\n      return\n    }\n\n    const leftSon = 2 * nodeIdx + 1\n    traverse(leftSon)\n    traverse(leftSon + 1)\n  }\n  traverse(0)\n\n  return {\n    leaves: knownLeaves,\n    leafIdxs,\n    proofIdxs,\n  }\n}\n","import {\n  Blake3256,\n  HexString,\n  compact,\n  u32,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  ExtraInfo,\n  ExtrinsicMetadata,\n  LookupValue,\n  MetadataDigest,\n  ScalePrimitive,\n  TypeRef,\n  extraInfo,\n  extrinsicMetadata,\n  lookupType,\n  metadataDigest,\n  extrinsicDec,\n} from \"./codecs\"\nimport { getAccessibleTypes } from \"./get-accessible-types\"\nimport { getLookup } from \"./get-lookup\"\nimport { getMetadata } from \"./get-metadata\"\nimport { compactTypeRefs, mergeUint8, toBytes } from \"./utils\"\nimport { decodeAndCollectKnownLeafs } from \"./decode-and-collect\"\nimport { getProofData } from \"./proof\"\nimport { getDynamicBuilder, getLookupFn } from \"@polkadot-api/metadata-builders\"\n\nexport interface MetadataMerkleizer {\n  /**\n   * @returns Digest value of the metadata (aka its merkleized root-hash)\n   */\n  digest: () => Uint8Array\n\n  /**\n   * Get proof for an `Extrinsic`.\n   *\n   * @param transaction         Encoded `Extrinsic`, both signed or unsigned.\n   * @param txAdditionalSigned  Optionally collect types for given\n   *                            `additionalSigned` part of signedExtensions.\n   * @returns Encoded `Proof`\n   */\n  getProofForExtrinsic: (\n    transaction: Uint8Array | HexString,\n    txAdditionalSigned?: Uint8Array | HexString,\n  ) => Uint8Array\n\n  /**\n   * Get proof for `ExtrinsicPayload` parts.\n   *\n   * @param callData              Call data of the transaction. It has to be\n   *                              bare; i.e.\n   *                              without prepended compact length.\n   * @param includedInExtrinsic   Extra part of the signed extensions, all of\n   *                              them concatenated.\n   * @param includedInSignedData  Additional signed part of the signed\n   *                              extensions, all of them concatenated.\n   * @returns Encoded `Proof`\n   */\n  getProofForExtrinsicParts: (\n    callData: Uint8Array | HexString,\n    includedInExtrinsic: Uint8Array | HexString,\n    includedInSignedData: Uint8Array | HexString,\n  ) => Uint8Array\n\n  /**\n   * Get proof for `ExtrinsicPayload`.\n   *\n   * @param extrinsicPayload  Call data, extra part of signedExtensions and\n   *                          additional signed part of signedExtensions\n   *                          concatenated. It has to be bare; i.e. without\n   *                          prepended compact length.\n   * @returns Encoded `Proof`\n   */\n  getProofForExtrinsicPayload: (\n    extrinsicPayload: Uint8Array | HexString,\n  ) => Uint8Array\n}\n\nconst assertExpected = <T>(name: string, expected: T, received?: T): void => {\n  if (received != null && received !== expected)\n    throw new Error(\n      `${name} not expected. Received ${received} expected ${expected}`,\n    )\n}\n\nexport const merkleizeMetadata = (\n  metadataBytes: Uint8Array | HexString,\n  {\n    decimals,\n    tokenSymbol,\n    ...hinted\n  }: { decimals: number; tokenSymbol: string } & Partial<ExtraInfo>,\n): MetadataMerkleizer => {\n  const metadata = getMetadata(metadataBytes)\n  const { ss58Prefix, buildDefinition } = getDynamicBuilder(\n    getLookupFn(metadata),\n  )\n  if (ss58Prefix == null) throw new Error(\"SS58 prefix not found in metadata\")\n  assertExpected(\"SS58 prefix\", ss58Prefix, hinted.base58Prefix)\n  const version = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"Version\")\n  if (version == null) throw new Error(\"System.Version constant not found\")\n  const { spec_name: specName, spec_version: specVersion } = buildDefinition(\n    version.type,\n  ).dec(version.value)\n  if (typeof specName !== \"string\" || typeof specVersion !== \"number\")\n    throw new Error(\"Spec name or spec version not found\")\n  assertExpected(\"Spec name\", specName, hinted.specName)\n  assertExpected(\"Spec version\", specVersion, hinted.specVersion)\n\n  const info: ExtraInfo = {\n    decimals,\n    tokenSymbol,\n    specVersion,\n    specName,\n    base58Prefix: ss58Prefix,\n  }\n  const definitions = new Map<number, LookupValue>(\n    metadata.lookup.map((value) => [value.id, value]),\n  )\n  const accessibleTypes = getAccessibleTypes(metadata, definitions)\n  const getPrimitive = (frameId: number): ScalePrimitive[\"tag\"] | null => {\n    const {\n      def: { tag, value },\n    } = definitions.get(frameId)!\n\n    if (tag === \"primitive\") return value.tag\n\n    if ((tag !== \"composite\" && tag !== \"tuple\") || value.length > 1)\n      throw new Error(\"The provided definition doesn't map to a primitive\")\n\n    return value.length === 0\n      ? null // signals `void`\n      : getPrimitive(tag === \"tuple\" ? value[0] : value[0].type)\n  }\n\n  const getTypeRef = (frameId: number): TypeRef => {\n    const { def } = definitions.get(frameId)!\n\n    if (def.tag === \"primitive\") return { tag: def.value.tag, value: undefined }\n\n    if (def.tag === \"compact\") {\n      const primitive = getPrimitive(def.value)\n      const tag = compactTypeRefs[primitive as \"u8\"]\n      if (!tag) throw new Error(\"Invalid primitive for Compact\")\n      return { tag, value: undefined }\n    }\n\n    return accessibleTypes.has(frameId)\n      ? { tag: \"perId\", value: accessibleTypes.get(frameId)! }\n      : { tag: \"void\", value: undefined }\n  }\n\n  const extrinsic: ExtrinsicMetadata = {\n    version: metadata.extrinsic.version,\n    addressTy: getTypeRef(metadata.extrinsic.address),\n    callTy: getTypeRef(metadata.extrinsic.call),\n    signatureTy: getTypeRef(metadata.extrinsic.signature),\n    signedExtensions: metadata.extrinsic.signedExtensions.map((se) => ({\n      identifier: se.identifier,\n      includedInExtrinsic: getTypeRef(se.type),\n      includedInSignedData: getTypeRef(se.additionalSigned),\n    })),\n  }\n\n  const lookup = getLookup(\n    definitions,\n    accessibleTypes,\n    getTypeRef,\n    getPrimitive,\n  )\n  const lookupEncoded = lookup.map(lookupType.enc)\n\n  let hashTree: Array<Uint8Array> | undefined\n  const getHashTree = (): Array<Uint8Array> => {\n    if (hashTree) return hashTree\n\n    if (!lookupEncoded.length) return (hashTree = [new Uint8Array(32).fill(0)])\n\n    hashTree = new Array(lookupEncoded.length * 2 - 1)\n\n    let leavesStartIdx = lookupEncoded.length - 1\n    for (let i = 0; i < lookupEncoded.length; i++)\n      hashTree[leavesStartIdx + i] = Blake3256(lookupEncoded[i])\n\n    for (let i = hashTree.length - 2; i > 0; i -= 2)\n      hashTree[(i - 1) / 2] = Blake3256(\n        mergeUint8([hashTree[i], hashTree[i + 1]]),\n      )\n\n    return hashTree\n  }\n\n  let digested: undefined | Uint8Array\n  const digest = () => {\n    if (digested) return digested\n    const rootLookupHash = getHashTree()[0]\n\n    const digest: MetadataDigest = {\n      tag: \"V1\",\n      value: {\n        typeInformationTreeRoot: rootLookupHash,\n        extrinsicMetadataHash: Blake3256(extrinsicMetadata.enc(extrinsic)),\n        ...info,\n      },\n    }\n\n    return (digested = Blake3256(metadataDigest.enc(digest)))\n  }\n\n  const generateProof = (knownIndexes: number[]) => {\n    const proofData = getProofData(lookupEncoded, knownIndexes)\n\n    const hashTree = getHashTree()\n    const proofs = proofData.proofIdxs.map((idx) => hashTree[idx])\n\n    return mergeUint8([\n      compact.enc(proofData.leaves.length),\n      ...proofData.leaves,\n      compact.enc(proofData.leafIdxs.length),\n      ...proofData.leafIdxs.map((x) => u32.enc(x)),\n      compact.enc(proofs.length),\n      ...proofs,\n      extrinsicMetadata.enc(extrinsic),\n      extraInfo.enc(info),\n    ])\n  }\n\n  const getProofForExtrinsicPayload = (\n    extrinsicPayload: Uint8Array | HexString,\n  ) => {\n    const typeRefs: Array<TypeRef> = [\n      extrinsic.callTy,\n      ...extrinsic.signedExtensions.map((x) => x.includedInExtrinsic),\n      ...extrinsic.signedExtensions.map((x) => x.includedInSignedData),\n    ]\n    return generateProof(\n      decodeAndCollectKnownLeafs(extrinsicPayload, typeRefs, lookup),\n    )\n  }\n\n  const getProofForExtrinsicParts = (\n    callData: Uint8Array | HexString,\n    includedInExtrinsic: Uint8Array | HexString,\n    includedInSignedData: Uint8Array | HexString,\n  ) => {\n    const bytes = mergeUint8(\n      [callData, includedInExtrinsic, includedInSignedData].map(toBytes),\n    )\n    return getProofForExtrinsicPayload(bytes)\n  }\n\n  const getProofForExtrinsic = (\n    transaction: Uint8Array | HexString,\n    txAdditionalSigned?: Uint8Array | HexString,\n  ) => {\n    let [, { version, signed }, bytes] = extrinsicDec(transaction)\n\n    if (version !== extrinsic.version)\n      throw new Error(\"Incorrect extrinsic version\")\n\n    const typeRefs: TypeRef[] = signed\n      ? [\n          extrinsic.addressTy,\n          extrinsic.signatureTy,\n          ...extrinsic.signedExtensions.map((x) => x.includedInExtrinsic),\n          extrinsic.callTy,\n        ]\n      : [extrinsic.callTy]\n\n    if (txAdditionalSigned) {\n      bytes = mergeUint8([bytes, toBytes(txAdditionalSigned)])\n      typeRefs.push(\n        ...extrinsic.signedExtensions.map((x) => x.includedInSignedData),\n      )\n    }\n\n    return generateProof(decodeAndCollectKnownLeafs(bytes, typeRefs, lookup))\n  }\n\n  return {\n    digest,\n    getProofForExtrinsic,\n    getProofForExtrinsicParts,\n    getProofForExtrinsicPayload,\n  }\n}\n"],"names":["u32","str","u16","u8","Struct","Bytes","ScaleEnum","_void","compactNumber","Option","Vector","bool","enhanceDecoder","Tuple","compact","decAnyMetadata","fromHex","u64","u128","u256","i8","i16","i32","i64","i128","i256","typeRef","createDecoder","lookup","getDynamicBuilder","getLookupFn","Blake3256","digest","hashTree","version"],"mappings":"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"}