import { findAllIndexes } from "../utils/find-all-indexes.js";
import { interlace } from "../utils/interlace.js";
import { atomFamilyWithErrorCatcher } from "../utils/jotai/atom-family-with-error-catcher.js";
import { atomWithObservableAndPromise } from "../utils/jotai/atom-with-observable-and-promise.js";
import { maybePromiseAll } from "../utils/maybe-promise-all.js";
import { objectId } from "../utils/object-id.js";
import { useConfig } from "./use-config.js";
import { usePausableAtomValue } from "./use-pausable-atom-value.js";
import { useQueryOptions } from "./use-query-options.js";
import { useQueryRefresher } from "./use-query-refresher.js";
import { typedApiAtom } from "./use-typed-api.js";
import { idle, } from "@reactive-dot/core";
import { flatHead, stringify, } from "@reactive-dot/core/internal.js";
import { preflight, query } from "@reactive-dot/core/internal/actions.js";
import { atom } from "jotai";
import { soon } from "jotai-derive";
import { atomWithRefresh } from "jotai/utils";
import { useMemo } from "react";
import { from } from "rxjs";
import { switchMap } from "rxjs/operators";
export function useLazyLoadQuery(queryOrOptions, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
mayBeOptions) {
    const options = useQueryOptions(
    // @ts-expect-error complex overload
    queryOrOptions, mayBeOptions);
    const partialData = usePausableAtomValue(queryPayloadAtom(useConfig(), useMemo(() => options.filter((options) => options.query !== undefined), [options])));
    return useMemo(() => {
        const unflattenedData = interlace(partialData, findAllIndexes(options, (options) => options.query === undefined).map((index) => [idle, index]));
        return !Array.isArray(queryOrOptions)
            ? flatHead(unflattenedData)
            : unflattenedData;
    }, [options, partialData, queryOrOptions]);
}
/**
 * Hook for querying data from chain, returning the response & a refresher function.
 *
 * @param query - The function to create the query
 * @param options - Additional options
 * @returns The data response & a function to refresh it
 */
export function useLazyLoadQueryWithRefresh(...args) {
    // @ts-expect-error need to spread args
    const data = useLazyLoadQuery(...args);
    // @ts-expect-error need to spread args
    const refresh = useQueryRefresher(...args);
    return [data, refresh];
}
const instructionPayloadAtom = atomFamilyWithErrorCatcher((withErrorCatcher, config, chainId, instruction) => {
    switch (preflight(instruction)) {
        case "promise": {
            const atom = withErrorCatcher(atomWithRefresh((get, { signal }) => soon(get(typedApiAtom(config, chainId)), (api) => query(api, instruction, { signal }))));
            return {
                observableAtom: atom,
                promiseAtom: atom,
            };
        }
        case "observable":
            return atomWithObservableAndPromise((get) => from(Promise.resolve(get(typedApiAtom(config, chainId)))).pipe(switchMap((api) => query(api, instruction))), withErrorCatcher);
    }
}, (config, chainId, instruction) => [objectId(config), chainId, stringify(instruction)].join());
/**
 * @internal
 */
export function getQueryInstructionPayloadAtoms(config, chainId, query) {
    return query.instructions.map((instruction) => {
        if (!("multi" in instruction)) {
            return instructionPayloadAtom(config, chainId, instruction);
        }
        return instruction.args.map((args) => {
            const { multi, ...rest } = instruction;
            return instructionPayloadAtom(config, chainId, { ...rest, args });
        });
    });
}
/**
 * @internal
 * TODO: should be memoized within render function instead
 * https://github.com/pmndrs/jotai/discussions/1553
 */
export const queryPayloadAtom = atomFamilyWithErrorCatcher((withErrorCatcher, config, params) => {
    const atoms = params.map((param) => getQueryInstructionPayloadAtoms(config, param.chainId, param.query));
    const unwrap = (atoms, asObservable) => (asObservable ? atoms.observableAtom : atoms.promiseAtom);
    const createAtom = (asObservable) => withErrorCatcher(atom((get) => {
        return maybePromiseAll(atoms.map((atomOrAtoms) => !Array.isArray(atomOrAtoms)
            ? atomOrAtoms
            : soon(maybePromiseAll(atomOrAtoms.map((atomOrAtoms) => {
                if (Array.isArray(atomOrAtoms)) {
                    return maybePromiseAll(atomOrAtoms.map((atom) => get(unwrap(atom, asObservable))));
                }
                return get(unwrap(atomOrAtoms, asObservable));
            })), flatHead)));
    }));
    return { promiseAtom: createAtom(false), observableAtom: createAtom(true) };
}, (config, params) => [
    objectId(config),
    ...params.map((param) => [
        param.chainId,
        stringify(param.query.instructions),
    ]),
].join());
//# sourceMappingURL=use-query.js.map