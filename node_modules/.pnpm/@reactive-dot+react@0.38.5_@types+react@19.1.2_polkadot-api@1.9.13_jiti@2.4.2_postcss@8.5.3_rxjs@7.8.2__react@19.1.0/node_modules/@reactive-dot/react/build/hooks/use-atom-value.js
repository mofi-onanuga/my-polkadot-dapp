// TODO: temporary workaround for https://github.com/pmndrs/jotai/discussions/2848
/* v8 ignore start */
import { useStore } from "jotai";
import ReactExports, { useDebugValue, useEffect, useReducer } from "react";
const isPromiseLike = (x) => typeof x?.then === "function";
const attachPromiseMeta = (promise) => {
    promise.status = "pending";
    promise.then((v) => {
        promise.status = "fulfilled";
        promise.value = v;
    }, (e) => {
        promise.status = "rejected";
        promise.reason = e;
    });
};
const use = ReactExports.use ||
    ((promise) => {
        if (promise.status === "pending") {
            throw promise;
        }
        else if (promise.status === "fulfilled") {
            return promise.value;
        }
        else if (promise.status === "rejected") {
            throw promise.reason;
        }
        else {
            attachPromiseMeta(promise);
            throw promise;
        }
    });
const continuablePromiseMap = new WeakMap();
const createContinuablePromise = (promise) => {
    let continuablePromise = continuablePromiseMap.get(promise);
    if (!continuablePromise) {
        continuablePromise = new Promise((resolve, reject) => {
            let curr = promise;
            const onFulfilled = (me) => (v) => {
                if (curr === me) {
                    resolve(v);
                }
            };
            const onRejected = (me) => (e) => {
                if (curr === me) {
                    reject(e);
                }
            };
            const registerCancelHandler = (p) => {
                if ("onCancel" in p && typeof p.onCancel === "function") {
                    p.onCancel((nextValue) => {
                        if (isPromiseLike(nextValue)) {
                            continuablePromiseMap.set(nextValue, continuablePromise);
                            curr = nextValue;
                            nextValue.then(onFulfilled(nextValue), onRejected(nextValue));
                            registerCancelHandler(nextValue);
                        }
                        else {
                            resolve(nextValue);
                        }
                    });
                }
            };
            promise.then(onFulfilled(promise), onRejected(promise));
            registerCancelHandler(promise);
        });
        continuablePromiseMap.set(promise, continuablePromise);
    }
    return continuablePromise;
};
export function useAtomValue(atom, options) {
    const store = useStore(options);
    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer((prev) => {
        const nextValue = store.get(atom);
        if (Object.is(prev[0], nextValue) &&
            prev[1] === store &&
            prev[2] === atom) {
            return prev;
        }
        return [nextValue, store, atom];
    }, undefined, () => [store.get(atom), store, atom]);
    let value = valueFromReducer;
    if (storeFromReducer !== store || atomFromReducer !== atom) {
        rerender();
        value = store.get(atom);
    }
    const delay = options?.delay;
    useEffect(() => {
        const unsub = store.sub(atom, () => {
            try {
                const value = store.get(atom);
                if (isPromiseLike(value)) {
                    attachPromiseMeta(createContinuablePromise(value));
                }
            }
            catch {
                /* empty */
            }
            if (typeof delay === "number") {
                // delay rerendering to wait a promise possibly to resolve
                // eslint-disable-next-line @eslint-react/web-api/no-leaked-timeout
                setTimeout(rerender, delay);
                return;
            }
            rerender();
        });
        rerender();
        return unsub;
    }, [store, atom, delay]);
    useDebugValue(value);
    // The use of isPromiseLike is to be consistent with `use` type.
    // `instanceof Promise` actually works fine in this case.
    if (isPromiseLike(value)) {
        const promise = createContinuablePromise(value);
        return use(promise);
    }
    return value;
}
//# sourceMappingURL=use-atom-value.js.map