import type { ChainHookOptions, InferQueryArgumentResult, QueryArgument, QueryOptions } from "./types.js";
import { type ChainId, type Config, type Query } from "@reactive-dot/core";
/**
 * Hook for querying data from chain, and returning the response.
 *
 * @param query - The function to create the query
 * @param options - Additional options
 * @returns The data response
 */
export declare function useLazyLoadQuery<TChainId extends ChainId | undefined, TQuery extends QueryArgument<TChainId>>(query: TQuery, options?: ChainHookOptions<TChainId>): InferQueryArgumentResult<TChainId, TQuery>;
/**
 * Hook for querying data from chain, and returning the response.
 *
 * @param options - The query options
 * @returns The data response
 */
export declare function useLazyLoadQuery<TChainIds extends Array<ChainId | undefined>, const TOptions extends {
    [P in keyof TChainIds]: QueryOptions<TChainIds[P]>;
}>(options: TOptions & {
    [P in keyof TChainIds]: QueryOptions<TChainIds[P]>;
}): {
    [P in keyof TOptions]: InferQueryArgumentResult<TOptions[P]["chainId"], TOptions[P]["query"]>;
};
/**
 * Hook for querying data from chain, returning the response & a refresher function.
 *
 * @param query - The function to create the query
 * @param options - Additional options
 * @returns The data response & a function to refresh it
 */
export declare function useLazyLoadQueryWithRefresh<TChainId extends ChainId | undefined, TQuery extends QueryArgument<TChainId>>(query: TQuery, options?: ChainHookOptions<TChainId>): [data: InferQueryArgumentResult<TChainId, TQuery>, refresh: () => void];
/**
 * Hook for querying data from chain, returning the response & a refresher function.
 *
 * @param query - The function to create the query
 * @param options - Additional options
 * @returns The data response & a function to refresh it
 */
export declare function useLazyLoadQueryWithRefresh<TChainIds extends Array<ChainId | undefined>, const TOptions extends {
    [P in keyof TChainIds]: QueryOptions<TChainIds[P]>;
}>(options: TOptions & {
    [P in keyof TChainIds]: QueryOptions<TChainIds[P]>;
}): [
    data: {
        [P in keyof TOptions]: InferQueryArgumentResult<TOptions[P]["chainId"], TOptions[P]["query"]>;
    },
    refresh: () => void
];
/**
 * @internal
 */
export declare function getQueryInstructionPayloadAtoms(config: Config, chainId: ChainId, query: Query): ({
    observableAtom: import("jotai").Atom<unknown>;
    promiseAtom: import("jotai").Atom<unknown>;
} | {
    observableAtom: import("jotai").Atom<unknown>;
    promiseAtom: import("jotai").Atom<unknown>;
}[])[];
/**
 * @internal
 * TODO: should be memoized within render function instead
 * https://github.com/pmndrs/jotai/discussions/1553
 */
export declare const queryPayloadAtom: import("../utils/jotai/atom-family.js").AtomFamily<[config: Config, params: {
    chainId: ChainId;
    query: Query;
}[]], {
    promiseAtom: import("jotai").Atom<(NoInfer<unknown[]> | Promise<NoInfer<unknown[]>>)[] | Promise<NoInfer<unknown[]>[]>>;
    observableAtom: import("jotai").Atom<(NoInfer<unknown[]> | Promise<NoInfer<unknown[]>>)[] | Promise<NoInfer<unknown[]>[]>>;
}>;
//# sourceMappingURL=use-query.d.ts.map