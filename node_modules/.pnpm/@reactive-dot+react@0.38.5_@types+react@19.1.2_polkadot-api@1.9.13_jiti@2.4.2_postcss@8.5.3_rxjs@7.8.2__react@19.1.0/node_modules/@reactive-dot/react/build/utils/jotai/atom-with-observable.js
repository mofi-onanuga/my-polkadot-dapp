// TODO: temporary workaround for https://github.com/pmndrs/jotai/discussions/2848
import { atom } from "jotai";
export function atomWithObservable(getObservable, options) {
    const returnResultData = (result) => {
        if ("e" in result) {
            throw result.e;
        }
        return result.d;
    };
    const observableResultAtom = atom((get) => {
        let observable = getObservable(get);
        const itself = observable[Symbol.observable]?.();
        if (itself) {
            observable = itself;
        }
        let resolve;
        const makePending = () => new Promise((r) => {
            resolve = r;
        }).finally(() => {
            if (isNotMounted()) {
                timer = setTimeout(unsubscribe, 1000);
            }
        });
        const initialResult = options && "initialValue" in options
            ? {
                d: typeof options.initialValue === "function"
                    ? options.initialValue()
                    : options.initialValue,
            }
            : makePending();
        let setResult;
        let lastResult;
        const listener = (result) => {
            lastResult = result;
            resolve?.(result);
            setResult?.(result);
        };
        let subscription;
        let timer;
        const isNotMounted = () => !setResult;
        const unsubscribe = () => {
            if (subscription) {
                subscription.unsubscribe();
                subscription = undefined;
            }
        };
        const start = () => {
            if (subscription) {
                clearTimeout(timer);
                subscription.unsubscribe();
            }
            subscription = observable.subscribe({
                next: (d) => listener({ d }),
                error: (e) => listener({ e }),
                complete: () => { },
            });
            if (isNotMounted() && options?.unstable_timeout) {
                timer = setTimeout(unsubscribe, options.unstable_timeout);
            }
        };
        start();
        const resultAtom = atom(lastResult || initialResult);
        resultAtom.onMount = (update) => {
            setResult = update;
            if (lastResult) {
                update(lastResult);
            }
            if (subscription) {
                clearTimeout(timer);
            }
            else {
                start();
            }
            return () => {
                setResult = undefined;
                if (options?.unstable_timeout) {
                    timer = setTimeout(unsubscribe, options.unstable_timeout);
                }
                else {
                    unsubscribe();
                }
            };
        };
        return [resultAtom, observable, makePending, start, isNotMounted];
    });
    const observableAtom = atom((get) => {
        const [resultAtom] = get(observableResultAtom);
        const result = get(resultAtom);
        if (result instanceof Promise) {
            return result.then(returnResultData);
        }
        return returnResultData(result);
    }, (get, set, data) => {
        const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);
        if ("next" in observable) {
            if (isNotMounted()) {
                set(resultAtom, makePending());
                start();
            }
            observable.next(data);
        }
        else {
            throw new Error("observable is not subject");
        }
    });
    return observableAtom;
}
//# sourceMappingURL=atom-with-observable.js.map