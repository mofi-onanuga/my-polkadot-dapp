import { merkleizeMetadata } from '@polkadot-api/merkleize-metadata';
import { Binary, u32, u16 } from '@polkadot-api/substrate-bindings';
import { mergeUint8 } from '@polkadot-api/utils';
import { getMetadata } from './get-metadata.mjs';
import { DEFAULT_SS58, CLA, INS, P1, P2 } from './consts.mjs';
import { getSignBytes, createV4Tx } from '@polkadot-api/signers-common';

var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _transport, _pubkeys, _deviceId, _LedgerSigner_instances, send_fn, safeSend_fn, getPublicKey_fn, sign_fn;
const METADATA_IDENTIFIER = "CheckMetadataHash";
const START_PATH = Uint8Array.from([44, 0, 0, 128, 98, 1, 0, 128]);
const MID_PATH = Uint8Array.from([0, 0, 0, 128]);
const HARDENED = 2147483648;
const encodePath = (path1, path2) => {
  if (!Number.isInteger(path1) || path1 < 0 || path1 >= HARDENED || !Number.isInteger(path2) || path2 < 0 || path2 >= HARDENED)
    throw new Error(`Invalid path segments ${path1}, ${path2}`);
  return mergeUint8(
    START_PATH,
    u32.enc(HARDENED + path1),
    MID_PATH,
    u32.enc(HARDENED + path2)
  );
};
const getPubkeyMapKey = (path1, path2) => {
  return `${path1}:${path2}`;
};
class LedgerSigner {
  constructor(transport) {
    __privateAdd(this, _LedgerSigner_instances);
    __privateAdd(this, _transport);
    __privateAdd(this, _pubkeys);
    // `${path1}:${path2}`
    __privateAdd(this, _deviceId);
    __privateSet(this, _transport, transport);
    __privateSet(this, _pubkeys, /* @__PURE__ */ new Map());
  }
  /**
   * Retrieve running app from device.
   *
   * This call prevents race conditions and waits until the device is free to
   * receive new messages.
   *
   * @returns App name and version.
   * @throws This could throw if the device is not connected, locked, etc.
   */
  async appInfo() {
    const res = Uint8Array.from(await __privateMethod(this, _LedgerSigner_instances, send_fn).call(this, 176, 1, 0, 0));
    const appName = Binary.fromBytes(res.slice(2, 2 + res[1])).asText();
    const appVersion = Binary.fromBytes(
      res.slice(2 + res[1] + 1, 2 + res[1] + 1 + res[2 + res[1]])
    ).asText();
    return { appName, appVersion };
  }
  /**
   * Get unique identifier of the seed phrase. It is useful to uniquely identify
   * each device/seed that is connected.
   *
   * This call prevents race conditions and waits until the device is free to
   * receive new messages.
   *
   * @returns DeviceId.
   * @throws This could throw if the device is not connected, locked, in a
   *         different app than Polkadot, etc.
   */
  async deviceId() {
    return __privateGet(this, _deviceId) == null ? __privateSet(this, _deviceId, u32.dec((await __privateMethod(this, _LedgerSigner_instances, getPublicKey_fn).call(this, 0, 0)).slice(0, 4))) : __privateGet(this, _deviceId);
  }
  /**
   * Get pubkey for a specific derivation path.
   *
   * This call prevents race conditions and waits until the device is free to
   * receive new messages.
   *
   * @param path1  Primary derivation index.
   * @param path2  Secondary derivation index. Defaults to 0.
   * @returns Public key.
   * @throws This could throw if the device is not connected, locked, in a
   *         different app than Polkadot, etc.
   */
  async getPubkey(path1, path2 = 0) {
    return await __privateMethod(this, _LedgerSigner_instances, getPublicKey_fn).call(this, path1, path2);
  }
  /**
   * Show address in device's screen.
   *
   * This call prevents race conditions and waits until the device is free to
   * receive new messages.
   *
   * @param ss58Prefix  SS58 prefix for address formatting.
   * @param path1       Primary derivation index.
   * @param path2       Secondary derivation index. Defaults to 0.
   * @returns Public key.
   * @throws This could throw if the device is not connected, locked, in a
   *         different app than Polkadot, etc.
   */
  async seeAddressInDevice(ss58Prefix, path1, path2 = 0) {
    return await __privateMethod(this, _LedgerSigner_instances, getPublicKey_fn).call(this, path1, path2, true, ss58Prefix);
  }
  /**
   * Create PolkadotSigner object from a specific derivation path and for a
   * specific network.
   *
   * This call prevents race conditions and waits until the device is free to
   * receive new messages.
   *
   * @param networkInfo  Off-chain info required to sign transactions. This
   *                     makes this object be network-specific.
   * @param path1        Primary derivation index.
   * @param path2        Secondary derivation index. Defaults to 0.
   * @returns PolkadotSigner object.
   * @throws This could throw if the device is not connected, locked, in a
   *         different app than Polkadot, etc.
   */
  async getPolkadotSigner(networkInfo, path1, path2 = 0) {
    const publicKey = await __privateMethod(this, _LedgerSigner_instances, getPublicKey_fn).call(this, path1, path2);
    const signTx = async (callData, signedExtensions, metadata) => {
      const merkleizer = merkleizeMetadata(metadata, networkInfo);
      const digest = merkleizer.digest();
      const v15 = getMetadata(metadata);
      if (v15.extrinsic.signedExtensions.find(
        ({ identifier }) => identifier === METADATA_IDENTIFIER
      ) == null)
        throw new Error("No `CheckMetadataHash` sigExt found");
      const extra = [];
      const additionalSigned = [];
      v15.extrinsic.signedExtensions.map(({ identifier }) => {
        if (identifier === METADATA_IDENTIFIER) {
          extra.push(Uint8Array.from([1]));
          additionalSigned.push(mergeUint8(Uint8Array.from([1]), digest));
          return;
        }
        const signedExtension = signedExtensions[identifier];
        if (!signedExtension)
          throw new Error(`Missing ${identifier} signed extension`);
        extra.push(signedExtension.value);
        additionalSigned.push(signedExtension.additionalSigned);
      });
      const toSign = mergeUint8(callData, ...extra, ...additionalSigned);
      const signature = await __privateMethod(this, _LedgerSigner_instances, sign_fn).call(this, path1, path2, toSign, merkleizer.getProofForExtrinsicPayload(toSign));
      return createV4Tx(v15, publicKey, signature, extra, callData);
    };
    return {
      publicKey,
      signTx,
      signBytes: getSignBytes(
        async (x) => (
          // the signature includes a "0x00" at the beginning, indicating a ed25519 signature
          // this is not needed for non-extrinsic signatures
          (await __privateMethod(this, _LedgerSigner_instances, sign_fn).call(this, path1, path2, x)).slice(1)
        )
      )
    };
  }
}
_transport = new WeakMap();
_pubkeys = new WeakMap();
_deviceId = new WeakMap();
_LedgerSigner_instances = new WeakSet();
send_fn = async function(...params) {
  while (__privateGet(this, _transport).exchangeBusyPromise)
    await __privateGet(this, _transport).exchangeBusyPromise;
  return await __privateGet(this, _transport).send(...params);
};
safeSend_fn = async function(...params) {
  const { appName, appVersion } = await this.appInfo();
  if (appName !== "Polkadot") throw new Error("Polkadot App is not opened");
  if (Number.parseInt(appVersion.split(".")[0]) < 100)
    throw new Error(`Polkadot App version ${appVersion} not expected`);
  return await __privateMethod(this, _LedgerSigner_instances, send_fn).call(this, ...params);
};
getPublicKey_fn = async function(path1, path2, seeAddressInDevice, ss58Prefix) {
  const key = getPubkeyMapKey(path1, path2);
  if (!seeAddressInDevice && __privateGet(this, _pubkeys).has(key))
    return __privateGet(this, _pubkeys).get(key);
  if (ss58Prefix != null && (!Number.isInteger(ss58Prefix) || ss58Prefix < 0 || ss58Prefix >= 1 << 16))
    throw new Error(`Invalid ss58Prefix ${ss58Prefix}`);
  const bufToSend = Buffer.from(
    // id + ss58 prefix
    mergeUint8(
      encodePath(path1, path2),
      Uint8Array.from(u16.enc(ss58Prefix ?? DEFAULT_SS58))
    )
  );
  const res = Uint8Array.from(
    await __privateMethod(this, _LedgerSigner_instances, safeSend_fn).call(this, CLA, INS.getAddress, seeAddressInDevice ? P1.showAddress : P1.getAddress, P2, bufToSend)
  );
  const pubkey = res.slice(0, 32);
  __privateGet(this, _pubkeys).set(getPubkeyMapKey(path1, path2), pubkey);
  return pubkey;
};
sign_fn = async function(path1, path2, payload, shortMetadata) {
  const path = encodePath(path1, path2);
  const chunks = [];
  chunks.push(Buffer.from(mergeUint8(path, u16.enc(payload.length))));
  const combinedPayload = shortMetadata == null ? payload : mergeUint8(payload, shortMetadata);
  let offset = 0;
  while (offset < combinedPayload.length) {
    const chunkEnd = Math.min(offset + 250, combinedPayload.length);
    chunks.push(Buffer.from(combinedPayload.slice(offset, chunkEnd)));
    offset = chunkEnd;
  }
  let result;
  for (let i = 0; i < chunks.length; i++) {
    result = await __privateMethod(this, _LedgerSigner_instances, safeSend_fn).call(this, CLA, shortMetadata == null ? INS.signRaw : INS.signTx, i === 0 ? P1.init : i === chunks.length - 1 ? P1.end : P1.continue, P2, chunks[i]);
  }
  if (result == null) throw null;
  return Uint8Array.from(result).slice(0, result.length - 2);
};

export { LedgerSigner };
//# sourceMappingURL=ledger-signer.mjs.map
